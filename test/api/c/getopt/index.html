<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../../img/favicon.ico">
  <title>Getopt - Jgseong's Note</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Getopt";
    var mkdocs_page_input_path = "test/api/c/getopt.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../../.." class="icon icon-home"> Jgseong's Note</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../../">Test</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../..">Jgseong's Note</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../..">Docs</a> &raquo;</li>
    
      
    
    <li>Getopt</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <!-- TITLE: getopt() -->

<!-- SUBTITLE: getopt(), getopt_long(), getopt_long_only() 사용법 -->

<h1 id="about-getopt">About getopt()</h1>
<ul>
<li>실행 명령(execution command)의 인자(arguments) 파싱(parsing)를 도와주는 함수</li>
<li>각 인자들은 일반적으로 공백 '<code></code>'과 single/double quotation mark <code>'</code> ,<code>"</code>로 구분</li>
<li>C/C++ 소스 코드의 <code>main(int argc, char *argv[])</code>의 parameter로 사용</li>
<li><code>int argc</code> : 인자의 갯수, 0번째는 실행명령을 포함</li>
<li><code>char *argv[]</code> : 인자 vector, 문자열 배열</li>
</ul>
<pre><code class="c">main(int argc, char *argv[])
{
#if 0
  e.g. argc, argv의 값.
   $ ./a.out -a -b -c data -d e.txt
  argc=7
  argv[0]=&quot;./a.out&quot;,  argv[1]=&quot;-a&quot;,  argv[2]=&quot;-b&quot;,  argv[3]=&quot;-c&quot;
  argv[4]=&quot;data&quot;,     argv[5]=&quot;-d&quot;,  argv[6]=&quot;e.txt&quot;
#endif
}
</code></pre>

<ul>
<li>리눅스에서 보통 <code>-</code>(dash)로 옵션을 사용, 옵션 인자의 시작하는 <code>-</code>는 문자, <code>--</code>는 문자열로 구분.</li>
<li>이런 형식의 옵션 인자를 처리하기 위한 라이브러리 함수로 <code>getopt()</code> 사용. (<code>-</code>로 시작하는 문자 옵션; <strong>short option</strong>)</li>
<li>GNU extension으로 <code>getopt_long()</code>, <code>getopt_long_only()</code> 사용. (<code>--</code>로 시작하는 문자열 옵션; <strong>long option</strong>)</li>
</ul>
<h2 id="man-getopt">man getopt</h2>
<pre><code class="bash">man 3 getopt
</code></pre>

<pre><code class="c">GETOPT(3)
NAME
       getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - Parse command-line options

SYNOPSIS
       #include &lt;unistd.h&gt;

       int getopt(int argc, char * const argv[],
                  const char *optstring);

       extern char *optarg;
       extern int optind, opterr, optopt;

       #include &lt;getopt.h&gt;

       int getopt_long(int argc, char * const argv[],
                  const char *optstring,
                  const struct option *longopts, int *longindex);

       int getopt_long_only(int argc, char * const argv[],
                  const char *optstring,
                  const struct option *longopts, int *longindex);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getopt(): _POSIX_C_SOURCE &gt;= 2 || _XOPEN_SOURCE
       getopt_long(), getopt_long_only(): _GNU_SOURCE
</code></pre>

<h2 id="_1">외부 전역 변수</h2>
<ul>
<li><code>optarg</code> : 해당 옵션의 추가적인 인자(문자열).</li>
<li><code>optind</code> : 현재 argv를 가리키는 index, 1부터 시작.</li>
<li><code>opterr</code> : getopt()의 에러 출력 flag, opterr=1이면 출력, 0이면 출력 안함. </li>
<li><code>optopt</code> : 에러가 난 문자를 저장.
  <strong>e.g.</strong> 옵션 인자가 <code>d</code>이고 <code>optsring="abc"</code>라면, <code>?</code>를 리턴하고 <code>optopt='d'</code>.</li>
</ul>
<h1 id="getopt">getopt()</h1>
<pre><code class="c">int getopt(int argc, char * const argv[], const char *optstring);
</code></pre>

<ul>
<li>it parses short option in a argument vector.</li>
<li><code>argc</code> : 인자의 총 개수, 보통 <code>main()</code>의 argc를 사용.</li>
<li><code>argv</code> : 인자의 문자열 배열, 보통 <code>main()</code>의 <code>argv</code>를 사용.</li>
<li><code>optstring</code> : 옵션으로 사용하는 문자들로 구성된 문자열.</li>
<li>추가적인 인자가 필요한 옵션 문자는 뒤에 <code>:</code> 또는 <code>::</code>를 사용.</li>
<li><code>:</code>는 옵션의 추가 인자를 공백 ('<code></code>') 또는 다음 문자부터 인자로 취급하여 <code>optarg</code>에 저장</li>
<li><code>::</code>는 옵션의 추가 인자를 다음 문자부터 문자열로 취급 <code>optarg</code>에 저장. 공백 ('<code></code>')은 허용안함.</li>
<li><code>optstring</code>의 첫 문자가 <code>-</code>인 경우, <code>?</code> 대신 <code>1</code>를 리턴하며, 오류 출력을 하지 않음.</li>
<li><code>optstring</code>의 첫 문자가 <code>+</code>인 경우, 인자에 대해 오류가 발생하면 바로 파싱을 중지(<code>-1</code>를 리턴).</li>
<li><code>optstring</code>의 첫 문자가 <code>:</code>인 경우(<code>-</code>,<code>+</code>다음에 사용하면 중복 가능), 오류를 출력하지 않음. </li>
<li>
<p><code>optstring</code>의 첫 문자가 ':'인 경우, <code>man 3 getopt</code>에서는 <code>?</code> 대신 <code>:</code>를 리턴한다고 되어 있으나, 동작되지 않음. (ubuntu 16 lts, glibc 2.23 기준)
     <strong>e.g.</strong> 옵션이 <code>a</code>,<code>b</code>,<code>c</code>이고 <code>b</code>는 추가적인 인자가 필요하다면 <code>b</code> 뒤에 <code>:</code>를 사용, <code>optstring="ab:c"</code>.</p>
</li>
<li>
<p><code>argv</code>에서 옵션 요소(element)를 검색, <code>optnid</code>와 함수 내부의 <code>static 변수 nextchar</code>(다음 문자(열)를 가리킴)를 이용.</p>
</li>
<li>반복적으로 수행되며, 모든 옵션을 파싱하면 <code>-1</code>을 리턴. <code>getopt()</code>의 동작을 초기화하려면 <code>optind=1</code>로 설정.</li>
<li>인자가 <code>optstring</code>에 포함된 옵션(문자)가 아니면 <code>?</code>를 리턴하고, 에러를 출력. 그리고 <code>optopt</code>에 현재 옵션 인자(문자)를 저장.</li>
<li>인자가 <code>optstring</code>에 해당하는 옵션이라면, 해당하는 옵션 문자를 리턴. 만일 추가 인자가 필요한 옵션이라면 <code>optarg</code>에 추가 인자는 <code>optarg</code>에 저장(복제가 아닌, 문자열의 주소를 저장).</li>
<li>리턴 값:</li>
<li>모든 옵션을 파싱하면 <code>-1</code>을 리턴.</li>
<li>해당하는 옵션이 아니면, <code>?</code>를 리턴하고 <code>optopt</code>에 에러 문자를 저장.</li>
<li>해당하는 옵션이라며, 해당 옵션 문자를 리턴하고, 추가 인자가 필요한 옵션은 <code>optarg</code>에 추가 인자가 저장.
    <strong>e.g.</strong> shell에서 <code>./a.out -a -b</code>를 수행한 경우, <code>a.out</code>에서 <code>getopt()</code>를 수행하면, 처음에 <code>a</code>, 두번째에 <code>b</code>, 세번째에 <code>-1</code> 리턴. </li>
</ul>
<pre><code class="c">char c;
while((c=getopt(argc, argv, &quot;hvf:&quot;))==-1)
{
  switch(c)
  {
  case 'h':
    printf(&quot;option 'h'&quot;);
    break;
  case 'v':
    printf(&quot;option 'v'&quot;);
    break;
  case 'f':
    printf(&quot;option 'f'&quot;);
    printf(&quot;option argument is %s&quot;, optarg);  // f의 추가 인자(argument)
    break;
  case '?':
  default:
    printf(&quot;unknown option %c&quot;, optopt);
  }
}
</code></pre>

<h2 id="example-getopt_examplec">Example - getopt_example.c</h2>
<pre><code class="c">/* getopt_example.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;

// &quot;optarg&quot; and &quot;optopt&quot; are already decleared &quot;getopt.h&quot;

#define OPTFLG_H    0x01
#define OPTFLG_V    0x02
#define OPTFLG_F    0x04

void main(int argc, char* const *argv)
{
    int c;
    unsigned char flags=0x00;
    char farg[128];

    while((c=getopt(argc, argv, &quot;hvf:&quot;))!=-1)
    {
        switch(c)
        {
        case 'h':
            flags|=OPTFLG_H;
            break;
        case 'v':
            flags|=OPTFLG_V;
            break;
        case 'f':
            flags|=OPTFLG_F;
            memset(farg, 0, sizeof(farg));
            memcpy(farg, optarg, strlen(optarg));
            break;
        case '?':
            printf(&quot;Unknown flag : %c.\n&quot;, optopt);
            break;
        }
    }

    if(flags&amp;OPTFLG_H)
        printf(&quot;option 'h'\n&quot;);
    if(flags&amp;OPTFLG_V)
        printf(&quot;option 'v'\n&quot;);
    if(flags&amp;OPTFLG_F)
        printf(&quot;option 'f' : %s\n&quot;, farg);
}
</code></pre>

<h2 id="-getopt_examplec">실행 결과 - getopt_example.c</h2>
<pre><code class="bash">$ ./a.out -hf abc -v
option 'h'
option 'v'
option 'f' : abc
$ 
</code></pre>

<h1 id="getopt_long">getopt_long()</h1>
<pre><code class="c">int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);
</code></pre>

<ul>
<li>it parse short option and long option in a argument vector.</li>
<li><code>getopt()</code>와 유사하게 동작. </li>
<li><code>--</code>로 시작하는 문자열 옵션을 파싱. (GNU extension)</li>
<li><code>--arg=pram</code> 또는 <code>--arg pram</code>처럼 추가 인자를 사용 가능.</li>
<li><code>-</code>로 시작한 인자인 경우, <strong>short option</strong>이 우선순위가 높음.</li>
<li><code>longopts</code> : 사용할 <code>struct option</code> 배열, <strong>long</strong> 옵션을 정의, <code>struct option</code>은 <code>&lt;getopt.h&gt;</code>에 정의되어 있음.</li>
</ul>
<pre><code class="c">struct option {
  const char *name;
  int        has_arg;
  int        *flag;
  int        val;
}
</code></pre>

<ul>
<li><code>name</code> : long 옵션의 이름(문자열). <strong>e.g.</strong> <code>--arg</code>이면 <code>arg</code>.</li>
<li><code>has_arg</code> : 추가적인 인자의 사용 유무</li>
<li><code>no_argument</code> : defined 0, 추가 인자가 없음. </li>
<li><code>required_argument</code> : defined 1, 추가 인자가 반드시 사용.</li>
<li><code>optional_argument</code> : defined 2, 추가 인자가 선택적으로 사용.</li>
<li><code>flag</code> : <code>getopt_long()</code>의 리턴 방법을 지정.</li>
<li><code>NULL</code> : <code>getopt_long()</code>은 <code>val</code>을 리턴. (보통 <code>val</code>은 <code>name</code>에 해당하는 <strong>short option</strong> 문자)</li>
<li><code>non-zero</code> : <code>getopt_long()</code>은 <code>0</code>을 리턴하고, <code>val</code>의 값을 <code>flag</code>가 가리키는 변수에 저장. 에러 시, 저장 안함.</li>
<li><code>val</code> : <code>getopt_long()</code>이 리턴하는 값. <code>flag</code> 사용시, <code>flag</code>가 가리키는 변수에 저장될 값.<blockquote>
<p><strong>option</strong> 구조체 배열 마지막 요소는 모두 0으로 설정되어야 한다.</p>
</blockquote>
</li>
<li>
<p><code>longindex</code> : <code>NULL</code>이면 안됨. 매칭된 옵션이 <code>longopts</code>에서 선택된 옵션의 <code>index</code>를 저장할 변수의 주소.</p>
</li>
<li>
<p>리턴 값 : </p>
</li>
<li>모든 옵션을 파싱하면 -1을 리턴.</li>
<li>해당하는 옵션(<strong>short/long option</strong>)이 아니면, <code>?</code>를 리턴하고 <code>optopt</code>에 에러 문자를 저장.</li>
<li>해당하는 옵션이라며, val를 리턴하고, 추가 인자가 필요한 옵션은 <code>optarg</code>에 추가 인자가 저장.</li>
<li><code>flag</code>가 지정된 옵션이 매칭하면 <code>0</code>을 리턴하고, <code>flag</code>가 지정한 변수에 <code>val</code>을 저장.</li>
</ul>
<h2 id="example-getopt_long_examplec">Example - getopt_long_example.c</h2>
<pre><code class="c">/* getopt_long_example.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;

#define MAJOR_VER   1 
#define MINOR_VER   0

#define OPTFLG_H    0x01
#define OPTFLG_V    0x02
#define OPTFLG_P    0x04

void help()
{
    printf(
        &quot;-h, --help              print help.\n&quot;
        &quot;-v, --version           print version.\n&quot;
        &quot;-p, --print             print optarg.\n&quot;
        &quot;-d, --debug             print debug message\n&quot;
        );
}

void main(int argc, char* const *argv)
{
    int o, debug=0, optflg=0, optlind=0;
    char arg[128];
    struct option lopts[]={
            {&quot;help&quot;, no_argument, 0, 'h'},
            {&quot;version&quot;, no_argument, 0, 'v'},
            {&quot;print&quot;, required_argument, 0, 'p'},
            {&quot;debug&quot;, no_argument, &amp;debug, 1},
            {0, 0, 0, 0}
    };

    while((o=getopt_long(argc, argv, &quot;hvp:&quot;, lopts, &amp;optlind))!=-1)
    {
        switch(o)
        {
            case 0:
                break;
            case 'h':
                optflg|=OPTFLG_H;
                break;
            case 'v':
                optflg|=OPTFLG_V;
                break;
            case 'p':
                optflg|=OPTFLG_P;
                memset(arg, 0, sizeof(arg));
                memcpy(arg, optarg, strlen(optarg));
                break;
            case '?':
            default:
                printf(&quot;unknown option %c\n&quot;, optopt);
        }
    }

    if(debug)
        printf(&quot;DEBUG!!!\n&quot;);
    if(optflg&amp;OPTFLG_H)
        help();
    if(optflg&amp;OPTFLG_V)
        printf(&quot;getopt_long example ver.%d.%d\n&quot;, MAJOR_VER, MINOR_VER);
    if(optflg&amp;OPTFLG_P)
        printf(&quot;optional argument is \&quot;%s\&quot;.\n&quot;, arg);
}
</code></pre>

<h2 id="-getopt_long_examplec">실행 결과 - getopt_long_example.c</h2>
<pre><code class="bash">$ ./a.out --debug -vh --print Hello
DEBUG!!!
-h, --help              print help.
-v, --version           print version.
-p, --print             print optarg.
-d, --debug             print debug message
getopt_long example ver.1.0
optional argument is &quot;Hello&quot;.
$ 
</code></pre>

<h1 id="getopt_long_only">getopt_long_only</h1>
<pre><code class="c">int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);
</code></pre>

<ul>
<li><code>getopt_long()</code>와 거의 동일하게 동작. </li>
<li><code>getopt_long_only()</code>에서는 <code>-</code>와 <code>--</code>로 <strong>long option</strong> 사용.</li>
<li><code>getopt_long_only()</code>에서는 <code>-</code>에 <strong>short option</strong>이 있으면 <strong>long option</strong> 파싱 안됨.</li>
<li><code>getopt_long_only()</code>에서는 <code>-</code>에서 연속된 <strong>short option</strong> 파싱 안됨(하나만 가능).</li>
<li><strong>long option</strong>만 사용할거라면, <code>optstring</code>을 <code>""</code>(double quotation mark pair)로 지정. </li>
<li><code>""</code>은 NULL이 아닌 <strong>empty-string</strong>.</li>
</ul>
<h2 id="example-getopt_long_only_examplec">Example - getopt_long_only_example.c</h2>
<pre><code class="c">/* getopt_long_only_example.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;

#define MAJOR_VER   1 
#define MINOR_VER   0

#define OPTFLG_H    0x01
#define OPTFLG_V    0x02
#define OPTFLG_P    0x04

void help()
{
    printf(
        &quot;-h, --help              print help.\n&quot;
        &quot;-v, --version           print version.\n&quot;
        &quot;-p, --print             print optarg.\n&quot;
        &quot;-d, --debug             print debug message\n&quot;
        );
}

void main(int argc, char* const *argv)
{
    int o, debug=0, optflg=0, optlind=0;
    char arg[128];
    struct option lopts[]={
            {&quot;help&quot;, no_argument, 0, 'h'},
            {&quot;version&quot;, no_argument, 0, 'v'},
            {&quot;print&quot;, required_argument, 0, 'p'},
            {&quot;debug&quot;, no_argument, &amp;debug, 1},
            {0, 0, 0, 0}
    };

    while((o=getopt_long_only(argc, argv, &quot;&quot;, lopts, &amp;optlind))!=-1)
    {
        switch(o)
        {
            case 0:
                break;
            case 'h':
                optflg|=OPTFLG_H;
                break;
            case 'v':
                optflg|=OPTFLG_V;
                break;
            case 'p':
                optflg|=OPTFLG_P;
                memset(arg, 0, sizeof(arg));
                memcpy(arg, optarg, strlen(optarg));
                break;
            case '?':
            default:
                printf(&quot;unknown option %c\n&quot;, optopt);
        }
    }

    if(debug)
        printf(&quot;DEBUG!!!\n&quot;);
    if(optflg&amp;OPTFLG_H)
        help();
    if(optflg&amp;OPTFLG_V)
        printf(&quot;getopt_long example ver.%d.%d\n&quot;, MAJOR_VER, MINOR_VER);
    if(optflg&amp;OPTFLG_P)
        printf(&quot;optional argument is \&quot;%s\&quot;.\n&quot;, arg);
}
</code></pre>

<h2 id="-getopt_long_only_examplec">실행 결과 - getopt_long_only_example.c</h2>
<pre><code class="bash">$ ./a.out -debug -version --help -print=Hello
DEBUG!!!
-h, --help              print help.
-v, --version           print version.
-p, --print             print optarg.
-d, --debug             print debug message
getopt_long example ver.1.0
optional argument is &quot;Hello&quot;.
$ 
</code></pre>

<h1 id="_2">추가사항</h1>
<p><code>getsubopt()</code> : <code>getopt()</code>, <code>getopt_long()</code>으로 파싱된 인자에서 토큰을 기준으로 문자열을 파싱.</p>
<h1 id="references">References</h1>
<p>[1] http://www.joinc.co.kr/w/man/3/getopt 
[2] http://soooprmx.com/wp/archives/4993 </p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../../../..';</script>
    <script src="../../../../js/theme.js" defer></script>
      <script src="../../../../search/main.js" defer></script>

</body>
</html>
